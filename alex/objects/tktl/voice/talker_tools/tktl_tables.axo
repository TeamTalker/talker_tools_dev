<objdefs appVersion="1.0.12">
<<<<<<< HEAD
   <obj.normal id="Talker Tools Tables" uuid="f0e017e3-be1a-4eb7-b40f-d57c4888659f">
=======
   <obj.normal id="tktl tables" uuid="f0e017e3-be1a-4eb7-b40f-d57c4888659f">
>>>>>>> master
      <sDescription>Loads original Texas Instruments LPC coefficient tables.
Part of the Talker Tools object set.</sDescription>
      <author>Team Talker</author>
      <license>BSD</license>
      <inlets>
         <frac32buffer.positive name="tALKER" description="multiplexed lpc index values NOT AUDIO!!"/>
         <bool32.risingfalling name="gate" description="gate passthrough"/>
      </inlets>
      <outlets>
         <frac32buffer.bipolar name="tALKER"/>
<<<<<<< HEAD
         <bool32 name="gate" description="gate passthrough"/>
      </outlets>
      <displays/>
      <params>
         <int32 name="tables" description="LPC table-select (0 = auto-select)" noLabel="true">
=======
         <bool32 name="gate" description="gate pass-through"/>
      </outlets>
      <displays/>
      <params>
         <int32 name="tables" description="LPC table-select (0 = auto-select)">
>>>>>>> master
            <MinValue i="0"/>
            <MaxValue i="8"/>
         </int32>
         <bool32.tgl name="interpolation" description="frame interpolation on/off"/>
      </params>
      <attribs>
         <combo name="debug" description="display extended info in console">
            <MenuEntries>
               <string>off</string>
               <string>on</string>
            </MenuEntries>
            <CEntries>
               <string>0</string>
               <string>1</string>
            </CEntries>
         </combo>
      </attribs>
      <file-depends>
         <file-depend localFilename="data/lpc_tables.raw" targetPath="/shared/lpc/lpc_tables.raw"/>
      </file-depends>
      <depends>
         <depend>fatfs</depend>
      </depends>
      <code.declaration><![CDATA[//

/*
 * Based on code from
 * https://raw.githubusercontent.com/mamedev/mame/master/src/devices/sound/tms5110.cpp
<<<<<<< HEAD
 * 
=======
 *
>>>>>>> master
 * With huge thanks to:
 * Frank Palazzolo
 * Neill Corlett
 * Aaron Giles
 * Lord Nightmare
 * Couriersud
<<<<<<< HEAD
 * 
=======
 *
>>>>>>> master
 * Your work is amazing!
 */

/////////////////
// Object vars //
/////////////////

bool disable;
bool multiple_instance;
uint8_t load_status;
uint8_t tables;

////////////////////////
// STRUCT DEFINITIONS //
////////////////////////

// Struct pointer to hold data from LPC tables binary file copied to SDRAM
struct LpcTables {
    uint16_t    subtype;
    char        name[8];
    uint8_t     num_k;
    uint8_t     num_energy_bits;
    uint8_t     num_pitch_bits;
    uint8_t     num_k_bits[10];
    uint8_t     table_energy[16];
    uint8_t     table_pitch[64];
    int16_t     table_k[10][32];
    uint8_t     table_interp[8];
} *ptr_lpc_tables_sdram_start, *ptr_lpc_tables_sdram;

// Struct to hold frame data (current, previous frame, output frame)
struct LpcIndexValues {
	int32_t	energy;
	int32_t	pitch;
	int32_t	kvals[10];
} lpc_frame_old, lpc_frame_new, lpc_frame_out;

///////////////
// Variables //
///////////////

// Inter-frame interpolation position (current, previous)
uint8_t interp_position;
uint8_t interp_position_old;

// Current interpolation coefficient from table
uint8_t interp_coeff;

// Interpolation inhibit flags
bool unvoiced_flag_new;
bool unvoiced_flag_old;
bool silent_flag_new;
bool silent_flag_old;
bool interp_inhibit;

///////////////
// Functions //
///////////////

// Display info for selected LPC tables
void DisplayTablesInfo(LpcTables *tables, bool verbose) {
	LogTextMessage("\n==== Talker Tools Tables Message: ====");
	LogTextMessage("Selected LPC tables: %s", tables -> name);
	if(verbose) {
		LogTextMessage("Extended tables information");
		LogTextMessage("Subtype index: %d", tables -> subtype);
		LogTextMessage("Lattice filter bands: %d", tables -> num_k);
		LogTextMessage("Energy bits: %d", tables -> num_energy_bits);
		LogTextMessage("Pitch bits: %d\n", tables -> num_pitch_bits);
	};
};


//]]></code.declaration>
      <code.init><![CDATA[//

LogTextMessage("\n//////////////////////////////////////////");
LogTextMessage("// Initialising Talkie Tools LPC Tables //");
LogTextMessage("//////////////////////////////////////////\n");

if(attr_debug)
	LogTextMessage("Extended information display on\n");

////////////////////
// Error-checking //
////////////////////

disable = false;
load_status = 1;
tables = 7;

if(TktlShared::vsm2_word_count_ == 0) {
	LogTextMessage("ERROR: VSM2 ROM file not loaded, exiting");
	disable = true;
	return;
};

//////////////////////////////////////
// Attempts to load vsm2 into sdram //
//////////////////////////////////////

// Check if file already copied to SDRAM
// (pointer set in TktlShared class)
if(!TktlShared::ptr_lpc_coef_tables_sdram_) {

	// Run file-loader (in incl. file) and save return-status
	// Pointer to SDRAM data passed by reference
	load_status = TktlLoadFileSDRAM("/shared/tktl/talker_tools/lpc_tables.raw", TktlShared::ptr_lpc_coef_tables_sdram_, attr_debug);

	// Check return of file-loader function
	if(load_status != 0) {
		LogTextMessage("ERROR: File-loader failed to load file to SDRAM, exiting");
		return;
	};
} else {
	LogTextMessage("Reusing data loaded by the first instance of this object.");
	multiple_instance = true;
};

// Copy pointer so we can increment pointer location for alternative tables
ptr_lpc_tables_sdram_start = (struct LpcTables *)TktlShared::ptr_lpc_coef_tables_sdram_;
ptr_lpc_tables_sdram = ptr_lpc_tables_sdram_start;

////////////////
// Frame vars //
////////////////

interp_position		= 0;
interp_position_old		= 8;
interp_coeff			= 0;

unvoiced_flag_new		= false;
unvoiced_flag_old		= false;
silent_flag_new		= false;
silent_flag_old		= false;
interp_inhibit			= true;

/////////////////////////////
// Zero frame data structs //
/////////////////////////////

lpc_frame_old			= {0};
lpc_frame_new			= {0};
lpc_frame_out		     = {0};

//]]></code.init>
      <code.krate><![CDATA[//


// Disable object k-rate execution is disable set
if(disable)
	return;

/////////////////////
// Set table index //
/////////////////////

if(tables != param_tables) {
	// Set table from inlet if set to 'auto'
	if(param_tables == 0) {
		ptr_lpc_tables_sdram = ptr_lpc_tables_sdram_start + TktlShared::vsm2_lpc_tables_id_;
	} else {
		ptr_lpc_tables_sdram = ptr_lpc_tables_sdram_start + (param_tables - 1);
	};
	// Log table ID to console
	DisplayTablesInfo(ptr_lpc_tables_sdram, attr_debug);
<<<<<<< HEAD
	tables = param_tables;	
=======
	tables = param_tables;
>>>>>>> master
};

///////////////////////
//Interpolate frames //
///////////////////////

// Interpolation turn ON
<<<<<<< HEAD
if(param_interpolation == 1) {
	
=======
if(param_interpolation) {

>>>>>>> master
	interp_position = inlet_tALKER[12];

	// Only interpolate if interpolation position changes
	if(interp_position != interp_position_old) {
<<<<<<< HEAD
		
=======

>>>>>>> master
		switch(interp_position) {

			/////////////////////
			// First sub-frame //
			/////////////////////
<<<<<<< HEAD
			
			case 0 :		
=======

			case 0 :
>>>>>>> master
				// Set voiced/unvoiced flag for incoming frame
				// Flag set if incoming pitch index = 0
				unvoiced_flag_new = (inlet_tALKER[1] == 0) ? true : false;
				// Calculate new silent flag (true if energy = 0)
				silent_flag_new = (inlet_tALKER[0] == 0) ? true : false;

				// Decide if interpolation is required for this frame
				if (((!unvoiced_flag_old) && unvoiced_flag_new) || ((unvoiced_flag_old) && !unvoiced_flag_new) || ((silent_flag_old) && !silent_flag_new))
					interp_inhibit = true;
				else
					// Normal frame, normal interpolation
					interp_inhibit = false;

				////////////////////////////
				// Capture new LPC values //
				////////////////////////////
<<<<<<< HEAD
				
				lpc_frame_new.energy	= ptr_lpc_tables_sdram -> table_energy[inlet_tALKER[0]];
				lpc_frame_new.pitch  	= ptr_lpc_tables_sdram -> table_pitch[inlet_tALKER[1]];
				lpc_frame_new.kvals[0]  	= ptr_lpc_tables_sdram -> table_k[0][inlet_tALKER[2]];
				lpc_frame_new.kvals[1]  	= ptr_lpc_tables_sdram -> table_k[1][inlet_tALKER[3]];
				lpc_frame_new.kvals[2]  	= ptr_lpc_tables_sdram -> table_k[2][inlet_tALKER[4]];
				lpc_frame_new.kvals[3]  	= ptr_lpc_tables_sdram -> table_k[3][inlet_tALKER[5]];
				lpc_frame_new.kvals[4]  	= ptr_lpc_tables_sdram -> table_k[4][inlet_tALKER[6]];
				lpc_frame_new.kvals[5]  	= ptr_lpc_tables_sdram -> table_k[5][inlet_tALKER[7]];
				lpc_frame_new.kvals[6]  	= ptr_lpc_tables_sdram -> table_k[6][inlet_tALKER[8]];
				lpc_frame_new.kvals[7]  	= ptr_lpc_tables_sdram -> table_k[7][inlet_tALKER[9]];
				lpc_frame_new.kvals[8]  	= ptr_lpc_tables_sdram -> table_k[8][inlet_tALKER[10]];
				lpc_frame_new.kvals[9]  	= ptr_lpc_tables_sdram -> table_k[9][inlet_tALKER[11]];
		
=======

				lpc_frame_new.energy   = ptr_lpc_tables_sdram -> table_energy[inlet_tALKER[0]];
				lpc_frame_new.pitch    = ptr_lpc_tables_sdram -> table_pitch[inlet_tALKER[1]];
				lpc_frame_new.kvals[0] = ptr_lpc_tables_sdram -> table_k[0][inlet_tALKER[2]];
				lpc_frame_new.kvals[1] = ptr_lpc_tables_sdram -> table_k[1][inlet_tALKER[3]];
				lpc_frame_new.kvals[2] = ptr_lpc_tables_sdram -> table_k[2][inlet_tALKER[4]];
				lpc_frame_new.kvals[3] = ptr_lpc_tables_sdram -> table_k[3][inlet_tALKER[5]];
				lpc_frame_new.kvals[4] = ptr_lpc_tables_sdram -> table_k[4][inlet_tALKER[6]];
				lpc_frame_new.kvals[5] = ptr_lpc_tables_sdram -> table_k[5][inlet_tALKER[7]];
				lpc_frame_new.kvals[6] = ptr_lpc_tables_sdram -> table_k[6][inlet_tALKER[8]];
				lpc_frame_new.kvals[7] = ptr_lpc_tables_sdram -> table_k[7][inlet_tALKER[9]];
				lpc_frame_new.kvals[8] = ptr_lpc_tables_sdram -> table_k[8][inlet_tALKER[10]];
				lpc_frame_new.kvals[9] = ptr_lpc_tables_sdram -> table_k[9][inlet_tALKER[11]];

>>>>>>> master
				if(interp_inhibit) {
					// Interpolation IS inhibited
					// Set outputs to new frame
					lpc_frame_out = lpc_frame_new;
				} else {
					// Interpolation NOT inhibited
					// Set outputs to old frame for start of interpolation sub-frame sequence
					lpc_frame_out = lpc_frame_old;
				};
				break;

			///////////////////////////////////////////
			// (Potentially) interpolated sub-frames //
			///////////////////////////////////////////
<<<<<<< HEAD
			
			case 1: case 2: case 3: case 4: case 5: case 6:
				
				// Interpolation inhibited 
				if(interp_inhibit) {									
					lpc_frame_out = lpc_frame_new;								
=======

			case 1: case 2: case 3: case 4: case 5: case 6:

				// Interpolation inhibited
				if(interp_inhibit) {
					lpc_frame_out = lpc_frame_new;
>>>>>>> master
				// Interpolate
				} else {
					// Extract current interpolation coefficient from table
					interp_coeff = ptr_lpc_tables_sdram -> table_interp[interp_position];

<<<<<<< HEAD
					// lpc_frame_out_energy += ((lpc_frame_new_energy - lpc_frame_out_energy) >> interp_coeff);
=======
>>>>>>> master
					lpc_frame_out.energy   += ((lpc_frame_new.energy   - lpc_frame_out.energy)   >> interp_coeff);
					lpc_frame_out.pitch    += ((lpc_frame_new.pitch    - lpc_frame_out.pitch)    >> interp_coeff);
					lpc_frame_out.kvals[0] += ((lpc_frame_new.kvals[0] - lpc_frame_out.kvals[0]) >> interp_coeff);
					lpc_frame_out.kvals[1] += ((lpc_frame_new.kvals[1] - lpc_frame_out.kvals[1]) >> interp_coeff);
					lpc_frame_out.kvals[2] += ((lpc_frame_new.kvals[2] - lpc_frame_out.kvals[2]) >> interp_coeff);
					lpc_frame_out.kvals[3] += ((lpc_frame_new.kvals[3] - lpc_frame_out.kvals[3]) >> interp_coeff);
					lpc_frame_out.kvals[4] += ((lpc_frame_new.kvals[4] - lpc_frame_out.kvals[4]) >> interp_coeff);
					lpc_frame_out.kvals[5] += ((lpc_frame_new.kvals[5] - lpc_frame_out.kvals[5]) >> interp_coeff);
					lpc_frame_out.kvals[6] += ((lpc_frame_new.kvals[6] - lpc_frame_out.kvals[6]) >> interp_coeff);
					lpc_frame_out.kvals[7] += ((lpc_frame_new.kvals[7] - lpc_frame_out.kvals[7]) >> interp_coeff);
					lpc_frame_out.kvals[8] += ((lpc_frame_new.kvals[8] - lpc_frame_out.kvals[8]) >> interp_coeff);
					lpc_frame_out.kvals[9] += ((lpc_frame_new.kvals[9] - lpc_frame_out.kvals[9]) >> interp_coeff);
<<<<<<< HEAD
				};	
=======
				};
>>>>>>> master

			////////////////////
			// Last sub-frame //
			////////////////////

			// Always new frame
			case 7 :
				// Set voiced/unvoiced flag for next frame
				unvoiced_flag_old = unvoiced_flag_new;
				silent_flag_old = silent_flag_new;
<<<<<<< HEAD
			
				// Copy current frame to old frame
				lpc_frame_out = lpc_frame_new;
				lpc_frame_old = lpc_frame_new;
			
				break;
		
		};	// End sub-frame logic
	};	// End interp_position change
 
	/////////////////////////////
	// Set interpolated output //
	/////////////////////////////
	
	outlet_tALKER[0]	= lpc_frame_out.energy;
	outlet_tALKER[1]	= lpc_frame_out.pitch;
	outlet_tALKER[2]	= lpc_frame_out.kvals[0];
	outlet_tALKER[3]	= lpc_frame_out.kvals[1];
	outlet_tALKER[4]	= lpc_frame_out.kvals[2];
	outlet_tALKER[5]	= lpc_frame_out.kvals[3];
	outlet_tALKER[6]	= lpc_frame_out.kvals[4];
	outlet_tALKER[7]	= lpc_frame_out.kvals[5];
	outlet_tALKER[8]	= lpc_frame_out.kvals[6];
	outlet_tALKER[9]	= lpc_frame_out.kvals[7];
	outlet_tALKER[10]	= lpc_frame_out.kvals[8];
	outlet_tALKER[11]	= lpc_frame_out.kvals[9];
=======

				// Copy current frame to old frame
				lpc_frame_out = lpc_frame_new;
				lpc_frame_old = lpc_frame_new;

				break;

		};	// End sub-frame logic
	};	// End interp_position change

	/////////////////////////////
	// Set interpolated output //
	/////////////////////////////

	outlet_tALKER[0]  = lpc_frame_out.energy;
	outlet_tALKER[1]  = lpc_frame_out.pitch;
	outlet_tALKER[2]  = lpc_frame_out.kvals[0];
	outlet_tALKER[3]  = lpc_frame_out.kvals[1];
	outlet_tALKER[4]  = lpc_frame_out.kvals[2];
	outlet_tALKER[5]  = lpc_frame_out.kvals[3];
	outlet_tALKER[6]  = lpc_frame_out.kvals[4];
	outlet_tALKER[7]  = lpc_frame_out.kvals[5];
	outlet_tALKER[8]  = lpc_frame_out.kvals[6];
	outlet_tALKER[9]  = lpc_frame_out.kvals[7];
	outlet_tALKER[10] = lpc_frame_out.kvals[8];
	outlet_tALKER[11] = lpc_frame_out.kvals[9];
>>>>>>> master

	// Update old interp_position
	interp_position_old = interp_position;


//////////////////////////////
// Interpolation turned OFF //
//////////////////////////////

// Set outlet values directly from inlets
} else {
<<<<<<< HEAD
	
	outlet_tALKER[0]  =  ptr_lpc_tables_sdram -> table_energy[inlet_tALKER[0]];
	outlet_tALKER[1]  =  ptr_lpc_tables_sdram -> table_pitch[inlet_tALKER[1]];	
=======

	outlet_tALKER[0]  =  ptr_lpc_tables_sdram -> table_energy[inlet_tALKER[0]];
	outlet_tALKER[1]  =  ptr_lpc_tables_sdram -> table_pitch[inlet_tALKER[1]];
>>>>>>> master
	outlet_tALKER[2]  =  ptr_lpc_tables_sdram -> table_k[0][inlet_tALKER[2]];
	outlet_tALKER[3]  =  ptr_lpc_tables_sdram -> table_k[1][inlet_tALKER[3]];
	outlet_tALKER[4]  =  ptr_lpc_tables_sdram -> table_k[2][inlet_tALKER[5]];
	outlet_tALKER[5]  =  ptr_lpc_tables_sdram -> table_k[3][inlet_tALKER[5]];
	outlet_tALKER[6]  =  ptr_lpc_tables_sdram -> table_k[4][inlet_tALKER[6]];
	outlet_tALKER[7]  =  ptr_lpc_tables_sdram -> table_k[5][inlet_tALKER[7]];
	outlet_tALKER[8]  =  ptr_lpc_tables_sdram -> table_k[6][inlet_tALKER[8]];
	outlet_tALKER[9]  =  ptr_lpc_tables_sdram -> table_k[7][inlet_tALKER[9]];
	outlet_tALKER[10] =  ptr_lpc_tables_sdram -> table_k[8][inlet_tALKER[10]];
	outlet_tALKER[11] =  ptr_lpc_tables_sdram -> table_k[9][inlet_tALKER[11]];
};

//////////////////////////////////////////////////
// Pass-through other multiplexed outlet values //
//////////////////////////////////////////////////

outlet_tALKER[12] = inlet_tALKER[12];
outlet_tALKER[13] = inlet_tALKER[13];
outlet_tALKER[14] = inlet_tALKER[14];
outlet_tALKER[15] = inlet_tALKER[15];

///////////////////////
// Pass through gate //
///////////////////////

outlet_gate = inlet_gate;

//]]></code.krate>
   </obj.normal>
</objdefs>
